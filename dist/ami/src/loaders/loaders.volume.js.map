{"version":3,"sources":["../../../../ami/src/loaders/loaders.volume.js"],"names":["PAKO","require","LoadersVolumes","response","emit","file","url","time","Date","_progressBar","update","Promise","resolve","reject","window","setTimeout","data","Array","isArray","forEach","dataset","_preprocess","length","mhdFile","filter","_filterByExtension","bind","rawFile","extension","mhdBuffer","buffer","rawBuffer","Parser","_parser","error","filename","volumeParser","e","console","log","series","seriesInstanceUID","transferSyntaxUID","seriesDate","seriesDescription","studyDate","studyDescription","numberOfFrames","numberOfChannels","modality","segmentationType","segmentationSegments","patientID","patientName","patientAge","patientBirthdate","patientSex","stack","pixelRepresentation","pixelType","invert","spacingBetweenSlices","push","parseFrame","i","dataParser","frame","sopInstanceUID","index","rows","columns","pixelData","extractPixelData","pixelSpacing","sliceThickness","imageOrientation","rightHanded","imagePosition","dimensionIndexValues","bitsAllocated","instanceNumber","windowCenter","windowWidth","rescaleSlope","rescaleIntercept","minMax","minMaxPixelData","referencedSegmentNumber","_parsed","_totalParsed","total","parsed","toUpperCase","parsedUrl","parseUrl","pathname","query","gzcompressed","split","shift","pop","decompressedData","inflate","item"],"mappings":"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","file":"loaders.volume.js","sourcesContent":["/** * Imports ***/\r\nconst PAKO = require('pako');\r\n\r\nimport LoadersBase from './loaders.base';\r\nimport CoreUtils from '../core/core.utils';\r\nimport ModelsSeries from '../models/models.series';\r\nimport ModelsStack from '../models/models.stack';\r\nimport ModelsFrame from '../models/models.frame';\r\nimport ParsersDicom from '../parsers/parsers.dicom';\r\nimport ParsersMhd from '../parsers/parsers.mhd';\r\nimport ParsersNifti from '../parsers/parsers.nifti';\r\nimport ParsersNrrd from '../parsers/parsers.nrrd';\r\n\r\n/**\r\n *\r\n * It is typically used to load a DICOM image. Use loading manager for\r\n * advanced usage, such as multiple files handling.\r\n *\r\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\r\n *\r\n * @module loaders/volumes\r\n * @example\r\n * var files = ['/data/dcm/fruit'];\r\n *\r\n * // Instantiate a dicom loader\r\n * var lDicomoader = new dicom();\r\n *\r\n * // load a resource\r\n * loader.load(\r\n *   // resource URL\r\n *   files[0],\r\n *   // Function when resource is loaded\r\n *   function(object) {\r\n *     //scene.add( object );\r\n *     window.console.log(object);\r\n *   }\r\n * );\r\n */\r\nexport default class LoadersVolumes extends LoadersBase {\r\n  /**\r\n   * Parse response.\r\n   * response is formated as:\r\n   *    {\r\n   *      url: 'resource url',\r\n   *      buffer: xmlresponse,\r\n   *    }\r\n   * @param {object} response - response\r\n   * @return {promise} promise\r\n   */\r\n  parse(response) {\r\n    // emit 'parse-start' event\r\n    this.emit('parse-start', {\r\n      file: response.url,\r\n      time: new Date(),\r\n    });\r\n    // give a chance to the UI to update because\r\n    // after the rendering will be blocked with intensive JS\r\n    // will be removed after eventer set up\r\n    if (this._progressBar) {\r\n      this._progressBar.update(0, 100, 'parse');\r\n    }\r\n\r\n    return new Promise(\r\n      (resolve, reject) => {\r\n        window.setTimeout(\r\n          () => {\r\n            resolve(new Promise((resolve, reject) => {\r\n              let data = response;\r\n\r\n              if (!Array.isArray(data)) {\r\n                data = [data];\r\n              }\r\n\r\n              data.forEach((dataset) => {\r\n                this._preprocess(dataset);\r\n              });\r\n\r\n              if (data.length === 1) {\r\n                data = data[0];\r\n              } else {\r\n                // if raw/mhd pair\r\n                let mhdFile =\r\n                  data.filter(this._filterByExtension.bind(null, 'MHD'));\r\n                let rawFile =\r\n                  data.filter(this._filterByExtension.bind(null, 'RAW'));\r\n                if (data.length === 2 &&\r\n                    mhdFile.length === 1 &&\r\n                    rawFile.length === 1) {\r\n                  data.url = mhdFile[0].url;\r\n                  data.extension = mhdFile[0].extension;\r\n                  data.mhdBuffer = mhdFile[0].buffer;\r\n                  data.rawBuffer = rawFile[0].buffer;\r\n                }\r\n              }\r\n\r\n              let Parser = this._parser(data.extension);\r\n              if (!Parser) {\r\n                // emit 'parse-error' event\r\n                this.emit('parse-error', {\r\n                  file: response.url,\r\n                  time: new Date(),\r\n                  error: data.filename + 'can not be parsed.',\r\n                });\r\n                reject(data.filename + ' can not be parsed.');\r\n              }\r\n\r\n              // check extension\r\n              let volumeParser = null;\r\n              try {\r\n                volumeParser = new Parser(data, 0);\r\n              } catch (e) {\r\n                window.console.log(e);\r\n                // emit 'parse-error' event\r\n                this.emit('parse-error', {\r\n                  file: response.url,\r\n                  time: new Date(),\r\n                  error: e,\r\n                });\r\n                reject(e);\r\n              }\r\n\r\n              // create a series\r\n              let series = new ModelsSeries();\r\n              // global information\r\n              series.seriesInstanceUID = volumeParser.seriesInstanceUID();\r\n              series.transferSyntaxUID = volumeParser.transferSyntaxUID();\r\n              series.seriesDate = volumeParser.seriesDate();\r\n              series.seriesDescription = volumeParser.seriesDescription();\r\n              series.studyDate = volumeParser.studyDate();\r\n              series.studyDescription = volumeParser.studyDescription();\r\n              series.numberOfFrames = volumeParser.numberOfFrames();\r\n              if (!series.numberOfFrames) {\r\n                series.numberOfFrames = 1;\r\n              }\r\n              series.numberOfChannels = volumeParser.numberOfChannels();\r\n              series.modality = volumeParser.modality();\r\n              // if it is a segmentation, attach extra information\r\n              if (series.modality === 'SEG') {\r\n                // colors\r\n                // labels\r\n                // etc.\r\n                series.segmentationType = volumeParser.segmentationType();\r\n                series.segmentationSegments =\r\n                  volumeParser.segmentationSegments();\r\n              }\r\n              // patient information\r\n              series.patientID = volumeParser.patientID();\r\n              series.patientName = volumeParser.patientName();\r\n              series.patientAge = volumeParser.patientAge();\r\n              series.patientBirthdate = volumeParser.patientBirthdate();\r\n              series.patientSex = volumeParser.patientSex();\r\n\r\n              // just create 1 dummy stack for now\r\n              let stack = new ModelsStack();\r\n              stack.numberOfChannels = volumeParser.numberOfChannels();\r\n              stack.pixelRepresentation =\r\n                volumeParser.pixelRepresentation();\r\n              stack.pixelType = volumeParser.pixelType();\r\n              stack.invert = volumeParser.invert();\r\n              stack.spacingBetweenSlices =\r\n                volumeParser.spacingBetweenSlices();\r\n              stack.modality = series.modality;\r\n              // if it is a segmentation, attach extra information\r\n              if (stack.modality === 'SEG') {\r\n                // colors\r\n                // labels\r\n                // etc.\r\n                stack.segmentationType = series.segmentationType;\r\n                stack.segmentationSegments = series.segmentationSegments;\r\n              }\r\n              series.stack.push(stack);\r\n              // recursive call for each frame\r\n              // better than for loop to be able\r\n              // to update dom with \"progress\" callback\r\n              setTimeout(\r\n                this.parseFrame(\r\n                  series, stack, response.url, 0,\r\n                  volumeParser, resolve, reject), 0);\r\n            }));\r\n          }, 10);\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * recursive parse frame\r\n   * @param {ModelsSeries} series - data series\r\n   * @param {ModelsStack} stack - data stack\r\n   * @param {string} url - resource url\r\n   * @param {number} i - frame index\r\n   * @param {parser} dataParser - selected parser\r\n   * @param {promise.resolve} resolve - promise resolve args\r\n   * @param {promise.reject} reject - promise reject args\r\n   */\r\n  parseFrame(series, stack, url, i, dataParser, resolve, reject) {\r\n    let frame = new ModelsFrame();\r\n    frame.sopInstanceUID = dataParser.sopInstanceUID(i);\r\n    frame.url = url;\r\n    frame.index = i;\r\n    frame.rows = dataParser.rows(i);\r\n    frame.columns = dataParser.columns(i);\r\n    frame.numberOfChannels = stack.numberOfChannels;\r\n    frame.pixelRepresentation = stack.pixelRepresentation;\r\n    frame.pixelType = stack.pixelType;\r\n    frame.pixelData = dataParser.extractPixelData(i);\r\n    frame.pixelSpacing = dataParser.pixelSpacing(i);\r\n    frame.spacingBetweenSlices = dataParser.spacingBetweenSlices(i);\r\n    frame.sliceThickness = dataParser.sliceThickness(i);\r\n    frame.imageOrientation = dataParser.imageOrientation(i);\r\n    frame.rightHanded = dataParser.rightHanded();\r\n    stack.rightHanded = frame.rightHanded;\r\n    if (frame.imageOrientation === null) {\r\n      frame.imageOrientation = [1, 0, 0, 0, 1, 0];\r\n    }\r\n    frame.imagePosition = dataParser.imagePosition(i);\r\n    if (frame.imagePosition === null) {\r\n      frame.imagePosition = [0, 0, i];\r\n    }\r\n    frame.dimensionIndexValues = dataParser.dimensionIndexValues(i);\r\n    frame.bitsAllocated = dataParser.bitsAllocated(i);\r\n    frame.instanceNumber = dataParser.instanceNumber(i);\r\n    frame.windowCenter = dataParser.windowCenter(i);\r\n    frame.windowWidth = dataParser.windowWidth(i);\r\n    frame.rescaleSlope = dataParser.rescaleSlope(i);\r\n    frame.rescaleIntercept = dataParser.rescaleIntercept(i);\r\n    // should pass frame index for consistency...\r\n    frame.minMax = dataParser.minMaxPixelData(frame.pixelData);\r\n\r\n    // if series.mo\r\n    if (series.modality === 'SEG') {\r\n      frame.referencedSegmentNumber = dataParser.referencedSegmentNumber(i);\r\n    }\r\n\r\n    stack.frame.push(frame);\r\n\r\n    // update status\r\n    this._parsed = i + 1;\r\n    this._totalParsed = series.numberOfFrames;\r\n\r\n    // will be removed after eventer set up\r\n    if (this._progressBar) {\r\n      this._progressBar.update(this._parsed, this._totalParsed, 'parse');\r\n    }\r\n\r\n    // emit 'parsing' event\r\n    this.emit('parsing', {\r\n      file: url,\r\n      total: this._totalParsed,\r\n      parsed: this._parsed,\r\n      time: new Date(),\r\n    });\r\n\r\n    if (this._parsed === this._totalParsed) {\r\n      // emit 'parse-success' event\r\n      this.emit('parse-success', {\r\n        file: url,\r\n        total: this._totalParsed,\r\n        parsed: this._parsed,\r\n        time: new Date(),\r\n      });\r\n\r\n      resolve(series);\r\n    } else {\r\n      setTimeout(\r\n        this.parseFrame(\r\n          series, stack, url, this._parsed, dataParser, resolve, reject), 0\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return parser given an extension\r\n   * @param {string} extension - extension\r\n   * @return {parser} selected parser\r\n   */\r\n  _parser(extension) {\r\n    let Parser = null;\r\n\r\n    switch (extension.toUpperCase()) {\r\n      case 'NII':\r\n      case 'NII_':\r\n        Parser = ParsersNifti;\r\n        break;\r\n      case 'DCM':\r\n      case 'DICOM':\r\n      case 'IMA':\r\n      case '':\r\n        Parser = ParsersDicom;\r\n        break;\r\n      case 'MHD':\r\n        Parser = ParsersMhd;\r\n        break;\r\n      case 'NRRD':\r\n        Parser = ParsersNrrd;\r\n        break;\r\n      default:\r\n        window.console.log('unsupported extension: ' + extension);\r\n        return false;\r\n    }\r\n    return Parser;\r\n  }\r\n\r\n\r\n  /**\r\n   * Pre-process data to be parsed (find data type and de-compress)\r\n   * @param {*} data\r\n   */\r\n  _preprocess(data) {\r\n    const parsedUrl = CoreUtils.parseUrl(data.url);\r\n    // update data\r\n    data.filename = parsedUrl.filename;\r\n    data.extension = parsedUrl.extension;\r\n    data.pathname = parsedUrl.pathname;\r\n    data.query = parsedUrl.query;\r\n\r\n    // unzip if extension is '.gz'\r\n    if (data.extension === 'gz') {\r\n      data.gzcompressed = true;\r\n      data.extension =\r\n        data.filename.split('.gz').shift().split('.').pop();\r\n      let decompressedData = PAKO.inflate(data.buffer);\r\n      data.buffer = decompressedData.buffer;\r\n    } else {\r\n      data.gzcompressed = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Filter data by extension\r\n   * @param {*} extension\r\n   * @param {*} item\r\n   * @returns Boolean\r\n   */\r\n  _filterByExtension(extension, item) {\r\n    if (item.extension.toUpperCase() === extension.toUpperCase()) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n"]}